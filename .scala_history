object MapThread {
def threadMap(List mappable) {
def threadMap(List : mappable) {
val mapThread = new Thread(new Runnable {
val mapped = mappable.map(x => x *2)
println(mapped)
}).start
}
def threadMap(mappable : List) {
val mapThread = new Thread(new Runnable {
val mapped = mappable.map(x => x *2)
println(mapped)
}).start
}
val list = List.range(0,1000)
list
list.map(x => x * 2)
list.map(x => x * 2).sum()
list.map(x => x * 2).sum
list.toParArray.map(x => x * 2).sum
val super = Map(x => 56
val super = Map(x => 56)
val supers = Map(x => 56)
val supers = Map(int x => 56)
val supers = Map(x -> 56)
val list = List.range(0,1000).map(x => x * 2).reduce((a,b) => a * b)
val list = List.range(0,1000).map(x => x * 2)
import scala.collection.immutable.Map
val m = Map(x => 56)
val m = Map("Hello" => 56)
val m = Map(case("Hello)" => 56)
val m = Map("Hello": 56)
val m = Map("Hello" -> 56)
m.get("Hello")
m.get("Hello").asInstanceOf[int]
m.get("Hello").asInstanceOf[Int]
m.reduce(x => x * 2)
m.reduce((x,y) => x * y)
m.reduce((x,y) => y)
val m = Map("Hello" -> 56 "Wow" -> 500)
val m = Map("Hello" -> 56;"Wow" -> 500)
val m = Map("Hello" -> 56, "Wow" -> 500)
m.reduce((x,y) => y)
m.reduce((x,y) => y * y)
val test = List.range(0,50)
test.foreach{x=> x*2}
val t = test.foreach{x=>x*2}
t
val t = test.foreach(x -> x * 2)
val t = test.foreach(val x -> x * 2)
val t = test.foreach{x -> x *2}
val t = test.foreach(x => x *2)
test
test.map(x => x * 2)
val testpar = test.par
test.map(x => x * 2)
testpar.map(x => x * 2)
val i = Array(1,2,3,4,5,6,7,8,9)
i[0]
i.max
i.foreach { x => x *2}
i.indexOf(0)
i.indexOf(2)
val i = Array(1,2,3,4,5,6,7,8,9,1,2,3,4,1,3,2,4)
i.indexOf(2)
i.indexOf(1)
i.sum
import java.net.Socket
val bitStream = {0,1,0,1,1,1,0,0,1,0,0,1,0,1,1,0}
val bitStream = Array(0,1,0,1,1,1,0,0,1,0,0,1,0,1,1,0)
import scala.sys.process._
val ls : String = "ls ~/"
ls !
import scala.language.postfixOps
ls !
val test : String = "ls /Users/ltbrady/Desktop"
test !
val dirs : Array[String] = test !
val dirs = test !
dirs
l
val l = List.range(0,100)
l.foreach {x => x  *2}
l
val l2 = l.foreach {x => x  *2}
l2
val l2 = l.foreach{x => x  *2}
val l2 = l.foreach{x -> x  *2}
val l2 = l.foreach(x => x * 2)
val l2 = l.foreach(var x => x * 2)
val l2 = l.foreach{x => println(x)}
val l2 = l.foreach{x => l2(x) = x * 2}
val l2 = l.foreach{x => l2[x] = x * 2}
val l2 : Array[Integer] = l.foreach{x => l2(x) = x * 2}
val l2 : Array[Int] = l.foreach{x => l2(x) = x * 2}
import java.nio.file.Paths
var test = Paths.get(new URI("google.com"))
import java.net.URI
var test = Paths.get(new URI("google.com"))
var test = Paths.get(new URI("https://google.com"))
var test = Paths.get(new URI("http://google.com"))
var test = Paths.get(new Path("/Users/ltbrady/Desktop"))
import java.nio.file.Path
var test = Paths.get(new Path("/Users/ltbrady/Desktop"))
var test = Paths.get("/Users/ltbrady/Desktop")
test.resolve
test.resolve()
exit
quit()
exit()
:exit
:quit
exit
quit
import scala.collection.immutable.Set
val s: Set = Set(1,2,3,4,5,6,7,7)
val s = Set(1,2,3,4,5,6,7,7)
s
val s : Object = Set(1,2,3,4,5,6,7,7)
s
s.foreach(x => x * 2)
val s = Set(1,2,3,4,5,6,7,7)
s.foreach(x => x * 2)
s
t = s.foreach(x => x * 2)
val t = s.foreach(x => x * 2)
t
s.foreach(x => x = x * 2)
s.foreach(x => x * 2)
s
println("Hello world")
